package de.thm.mni.compilerbau.phases._02_03_parser;

import java.util.List;
import java.util.LinkedList;
import java_cup.runtime.*;
import de.thm.mni.compilerbau.phases._01_scanner.Scanner;
import de.thm.mni.compilerbau.absyn.*;
import de.thm.mni.compilerbau.table.Identifier;
import de.thm.mni.compilerbau.utils.SplError;
import de.thm.mni.compilerbau.CommandLineOptions;

parser code {:
  public CommandLineOptions options = null;

  public void syntax_error(Symbol currentToken) {
    throw SplError.SyntaxError(new Position(currentToken.left, currentToken.right), ((Scanner)getScanner()).yytext());
  }
  
  /**
   * @return An empty list. (Uses LinkedList)
   */
  public static <E> List<E> nil() {
      return new LinkedList<E>();
  }
  
  /**
   * Constructs a list from a head and a tail without modifying the tail (Uses LinkedList).
   * Use this as a helper if you don't want to deal with constructing lists manually.
   *
   * @param head The head of the list
   * @param tail The tail of the list
   * @return A list containing the head element and all elements of tail
   */
  public static <E> List<E> cons(E head, List<E> tail) {
    List<E> copy = new LinkedList(tail);
    copy.add(0, head);
    return copy;
  }
:}

/* Terminals/Tokens */
terminal LBRACK, RBRACK, LPAREN, RPAREN, LCURL, RCURL;         //Braces, parenthesis, brackets
terminal LT, LE, GT, GE, NE, EQ;                               //Comparison operators
terminal PLUS, MINUS, STAR, SLASH;                             //Arithmetic operators
terminal ASGN, COMMA, COLON, SEMIC;                            //Other delimiters
terminal TYPE, PROC, ARRAY, OF, REF, VAR, IF, ELSE, WHILE;     //Keywords

/* Non-terminals */
terminal Identifier IDENT;    //Identifiers
terminal Integer INTLIT;      //Integer literals

non terminal Program program;
non terminal ArrayAccess ArrayAccess;
non terminal ArrayTypeExpression ArrayTypeExpression;
non terminal AssignStatement AssignStatement;
non terminal BinaryExpression BinaryExpression;
non terminal CallStatement CallStatement;
non terminal CompoundStatement CompoundStatement;
non terminal EmptyStatement EmptyStatement;
non terminal Expression Expression;
non terminal Expression CompareExpression;
non terminal Expression MulExpression;
non terminal Expression AddExpression;
non terminal Expression UnaryExpression;
non terminal Expression PrimaryExpression;
non terminal GlobalDeclaration GlobalDeclaration;
non terminal IfStatement IfStatement;
non terminal IntLiteral IntLiteral;
non terminal NamedTypeExpression NamedTypeExpression;
non terminal Variable NamedVariable;
non terminal ParameterDeclaration ParameterDeclaration;
non terminal ProcedureDeclaration ProcDeclaration;
non terminal Statement Statement;
non terminal TypeDeclaration TypeDeclaration;
non terminal TypeExpression TypeExpression;
non terminal Variable Var;
non terminal VariableDeclaration VarDeclaration;
non terminal VariableExpression VarExpression;
non terminal WhileStatement WhileStatement;
non terminal List<GlobalDeclaration> GlobalDeclarationList;
non terminal List<Statement> StatementList;
non terminal List<ParameterDeclaration> ParameterList;
non terminal List<Expression> Arguments;
non terminal List<Expression> ArgList;
non terminal List<VariableDeclaration> VarList;
non terminal Expression NotEmptyArg;
non terminal List<Statement> StatementList;
non terminal List<VariableDeclaration> VarList;
non terminal Comma;
non terminal CompOperator;


start with program;

program ::= GlobalDeclarationList; //TODO (assignment 2 and 3): Just a dummy, needs to be replaced by the actual spl grammar.
GlobalDeclarationList ::= GlobalDeclaration GlobalDeclarationList |  ;
GlobalDeclaration ::= TypeDeclaration | ProcDeclaration;

TypeDeclaration ::= TYPE IDENT EQ NamedTypeExpression SEMIC;
NamedTypeExpression ::= IDENT | ArrayTypeExpression;
ArrayTypeExpression ::= ARRAY LBRACK INTLIT RBRACK OF NamedTypeExpression;

ProcDeclaration ::= PROC IDENT LPAREN ParameterList RPAREN LCURL VarList StatementList RCURL;
VarList ::= VarDeclaration VarList | ;
VarDeclaration ::= VAR IDENT COLON NamedTypeExpression SEMIC;
ParameterList ::= ParameterDeclaration ParameterList | ;
ParameterDeclaration ::= IDENT COLON NamedTypeExpression Comma | REF COLON NamedTypeExpression Comma ;
Comma ::= | COMMA;
// eigenständig

StatementList ::= | Statement StatementList;
Statement ::= IfStatement | WhileStatement | AssignStatement | EmptyStatement | CompoundStatement | CallStatement;
IfStatement ::= IF LPAREN Expression RPAREN  StatementList
    | IF LPAREN Expression RPAREN StatementList  ELSE StatementList;
WhileStatement ::= WHILE LPAREN Expression RPAREN StatementList;
EmptyStatement ::= SEMIC;
AssignStatement ::= IDENT ASGN Expression;
CompoundStatement ::= LCURL StatementList RCURL;
//Verwendungsgrund Arguments: mehrere Argumente können übergeben werden
CallStatement ::= IDENT LPAREN Arguments  RPAREN;
Arguments ::= ArgList | ;
ArgList ::= NotEmptyArg | NotEmptyArg COMMA ArgList;
NotEmptyArg ::= Expression;
Expression ::= CompareExpression;
CompOperator ::= LT | LE | GT | GE | NE | EQ;
CompareExpression ::= AddExpression | AddExpression CompOperator AddExpression;
AddExpression ::= MulExpression | AddExpression PLUS MulExpression | AddExpression MINUS MulExpression;
MulExpression ::= UnaryExpression | MulExpression STAR UnaryExpression | MulExpression SLASH UnaryExpression;
UnaryExpression ::= PrimaryExpression | MINUS UnaryExpression;
PrimaryExpression ::= LPAREN Expression RPAREN | IntLiteral | VarExpression;
IntLiteral ::= INTLIT;
VarExpression ::= NamedVariable;
NamedVariable ::= IDENT | ArrayAccess;
ArrayAccess ::= NamedVariable LBRACK Expression RBRACK;
